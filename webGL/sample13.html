
<html>

<head>
<title>波形入力による振動シミュレーション</title>
<meta http-equiv="content-type" content="text/html; charset=ISO-8859-1">
<!-- 行列演算用 -->
<!-- <script type="text/javascript" src="script_table.js"></script> -->
<!-- 行列演算用 -->
<script type="text/javascript" src="js/matrix_library_v010g.js"></script>
<!-- スライダーＵＩ -->
<link rel="stylesheet" type="text/css" href="css/slider.css" />
<link rel="stylesheet" type="text/css" href="css/setpar.css" />
<script type="text/javascript">

var min1
var min2
var min3;
var max1;
var max2;
var max3;
// スライダーの最小・最大値のデフォルト
min1 = 0;
min2 = 0;
min3 = 0;
max1 = 100;
max2 = 1000;
max3 = 100;

function set_MinMax(){
document.getElementById('mass_min').value = min1;
document.getElementById('mass_max').value = max1;
document.getElementById('stif_min').value = min2;
document.getElementById('stif_max').value = max2;
document.getElementById('damp_min').value = min3;
document.getElementById('damp_max').value = max3;
}

function sliderControl(sliderI,sliderO,type){

if(type == '1'){
	var min_value   = parseFloat(min1);
	var max_value   = parseFloat(max1);
}
else if(type == '2'){
	var min_value   = parseFloat(min2);
	var max_value   = parseFloat(max2);
}
else if(type == '3'){
	var min_value   = parseFloat(min3);
	var max_value   = parseFloat(max3);
}

var slider 	= document.getElementById(sliderI);
var output 	= document.getElementById(sliderO);

var input 	= slider.getElementsByTagName('input')[0];
var dragging 	= false;
var value 	= output.value;		// 初期位置
var value_pos   = parseFloat(slider.clientHeight)/(max_value-min_value)*parseFloat(output.value);
var height 	= input.clientHeight 	/ 2;

var set_value = function (){
  // つまみのサイズ(input.clientWidth)だけ位置を調整
  input.style.top = (value_pos - input.clientHeight/2) + 'px';
  output.value = value;
};
set_value();
setMCK();

// 目盛り部分をクリックしたとき
slider.onclick = function(evt){
  dragging = true;
  document.onmousemove(evt);
  document.onmouseup();
};
// ドラッグ開始
input.onmousedown = function(evt){
  dragging = true;
  return false;
};
// ドラッグ終了
document.onmouseup = function(evt){
  if (dragging) {
    err_m = 0;
    err_c = 0;
    err_k = 0;
    
    dragging = false;
    //output1.value = value;
  }
};

document.onmousemove = function(evt){
  if(dragging){
    // ドラッグ途中
    if(!evt){
      evt = window.event;
    }
    var top = evt.clientY;
    var rect = slider.getBoundingClientRect();
    // マウス座標とスライダーの位置関係で値を決める
    value       = Math.round(top - rect.top) *(max_value-min_value)/parseFloat(slider.clientHeight);
    value_pos   = Math.round(top - rect.top);
    // スライダーからはみ出したとき
    if (value_pos <= 0) {
      value 	= min_value;
      value_pos = 0;
    } else if (value_pos > slider.clientHeight) {
      value 	= max_value;
      value_pos = slider.clientHeight;
    }
    set_value();
    setMCK();
    return false;
  }
};
};
</script>
<!-- 諸元設定・解析設定詳細項目ウィザード-->
<script type="text/javascript">
function setModel(mode){
	if( document.getElementById('parModel').style.display == 'block'){
		document.getElementById('parModel').style.display = 'none';
	}else{
		document.getElementById('parModel').style.display = 'block';
	}
}

// ###################################################################
function setPar(){
	if( document.getElementById('par').style.display == 'block'){
		document.getElementById('par').style.display = 'none';
	}else{
		document.getElementById('par').style.display = 'block';
	}
	var pre_min1 = min1;
	var pre_max1 = max1;
	var pre_min2 = min2;
	var pre_max2 = max2;
	var pre_min3 = min3;
	var pre_max3 = max3;
	
        min1 = document.getElementById('mass_min').value;
	max1 = document.getElementById('mass_max').value;
	min2 = document.getElementById('stif_min').value;
	max2 = document.getElementById('stif_max').value;
	min3 = document.getElementById('damp_min').value;
	max3 = document.getElementById('damp_max').value;
	if(min1 && max1 && min2 && max2 && min3 && max3){
		sliderAll();
	}
	else{
		alert('値が未入力です。入力された設定は反映されません');
		min1 = pre_min1;max1 = pre_max1;min2 = pre_min2;max2 = pre_max2;min3 = pre_min3;max3 = pre_max3;
		set_MinMax();
	}
}

function setInput(){
	if( document.getElementById('par_input').style.display == 'block'){
		document.getElementById('par_input').style.display = 'none';
	}else{
		document.getElementById('par_input').style.display = 'block';
	}
}

var icon_text_view = 0;
var cur_menu;
function changeValue(idname,text1,text2){
	if(idname){
		if(cur_menu){
			if(cur_menu != idname){
				icon_text_view = 0;
			}
		}
		var icon_onoff = 0;
		var i = 1;
		while(icon_onoff == '0'){
			if(idname != 'menu_'+i){
				document.getElementById('button_'+i).style.display = 'none';
			}
			if( i < 3){
				i++;
			}else{
				icon_onoff = 1;
			}
		}
		
		if(icon_text_view == '0'){
			document.getElementById(idname).innerHTML = text1;
			icon_text_view = 1;
		}else{
			document.getElementById(idname).innerHTML = text2;
			var icon_onoff = 0;
			var i = 1;
			while(icon_onoff == 0){
				document.getElementById('button_'+i).style.display = 'block';	
				if(i < 3){
					i++;
				}else{
					icon_onoff = 1;
				}
			}
			icon_text_view = 0;
		}
		cur_menu = idname;
	}
}
// >#### 建物モデルの自由度数を設定
var numNode = Number(1);
function setNumNode(){
	var modelId 	= document.getElementById('ModelList').value;
	if(modelId == '0'){
	        modelId 	= 1;
		numNode 	= Number(1);
	}
	else if(modelId == '1' || modelId == '2' || modelId == '3' ){
		numNode 	= Number(1);
	}
	else if(modelId == '4'){
		numNode 	= Number(2);
	}
	else if(modelId == '51'){
		numNode 	= Number(5);
	}

}

// >#### 全てのスライダーに設定された値を反映させる(複数のスライダーを対象）####
function sliderAll(){
	setNumNode(); 					// 建物モデル自由度数を再設定
	var icon_mass 	= 0;
	var icon_stif 	= 0;
	var icon_damp 	= 0;
	var count_mass 	= 0;
	var count_stif 	= 0;
	var count_damp 	= 0;
	for (var i = 1; i < 3 * numNode + 1; i++) {
	  	if(icon_mass == '0'){
			count_mass++;
			eval("sliderControl('div_slider_mass_" + count_mass + "','slider_mass_" + count_mass + "',1);");
			if(count_mass == numNode){
				icon_mass = 1;
			}
		}
		else if (icon_stif == '0'){
			count_stif++;
			eval("sliderControl('div_slider_stif_" + count_stif + "','slider_stif_" + count_stif + "',2);");
			if(count_stif == numNode){
				icon_stif = 1;
			}
		}
		else if (icon_damp == '0'){
			count_damp++;
			eval("sliderControl('div_slider_damp_" + count_damp + "','slider_damp_" + count_damp + "',3);");
			if(count_damp == numNode){
				icon_damp = 1;
			}
		}
	}
}

// >########################################################################

function setTable(){
// #### 既存のパラメタ―設定パネルを削除 ####
if(document.getElementById("setParTable")){
	var delTable = document.getElementById("setParTable");
	if(delTable){
	    delTable.parentNode.removeChild(delTable);
	}
}

// #### 操作パネルのIDを取得 ####
var mainDivID 	= document.getElementById('panel');

// #### モデルの取得 ####
var modelId 	= document.getElementById('ModelList').value;
if(modelId == '0'){
        modelId 	= 1;
	var numNode 	= Number(1);
}
else if(modelId == '1' || modelId == '2' || modelId == '3'){
	var numNode 	= Number(1);
}
else if(modelId == '4'){
	var numNode 	= Number(2);
}
else if(modelId == '51'){
	var numNode 	= Number(5);
}

for(var i = 1; i < numNode + 1; i++){
	eval("var slider_mass_" + i + " = document.createElement('input');");
	eval("slider_mass_" + i + ".type = 'text';");
	eval("slider_mass_" + i + ".id = 'slider_mass_" + i + "';");
	eval("slider_mass_" + i + ".setAttribute('class','setvalue');");
	
	eval("var slider_stif_" + i + " = document.createElement('input');");
	eval("slider_stif_" + i + ".type = 'text';");
	eval("slider_stif_" + i + ".id = 'slider_stif_" + i + "';");
	eval("slider_stif_" + i + ".setAttribute('class','setvalue');");

	eval("var slider_damp_" + i + " = document.createElement('input');");
	eval("slider_damp_" + i + ".type = 'text';");
	eval("slider_damp_" + i + ".id = 'slider_damp_" + i + "';");
	eval("slider_damp_" + i + ".setAttribute('class','setvalue');");
}


if(modelId == '1'){
　　 	slider_mass_1.value 	= 10;
　　 	slider_stif_1.value 	= 1000;
　　 	slider_damp_1.value 	= 0.1;
}
else if(modelId == '2'){
　　 	slider_mass_1.value 	= 100;
　　 	slider_stif_1.value 	= 10;
　　 	slider_damp_1.value 	= 1;
}
else if(modelId == '3'){
　　 	slider_mass_1.value 	= 100;
　　 	slider_stif_1.value 	= 0;
　　 	slider_damp_1.value 	= 0;
}
else if(modelId == '4'){
	var mass    = new Array(100,80);
	var stif    = new Array(1000,500);
	var damp    = new Array(20,15);
	var j 	    = 0;	
	for(var i = 1; i <= numNode; i++){
		eval('slider_mass_' + i +'.value = mass[' + j + '];');
		eval('slider_stif_' + i +'.value = stif[' + j + '];');
		eval('slider_damp_' + i +'.value = damp[' + j + '];');
		j++;		
	}
}
else if(modelId == '51'){
	var mass    = new Array(100,80,60,40,20);
	var stif    = new Array(1000,500,500,500,300);
	var damp    = new Array(20,15,10,10,10);
	var j 	    = 0;	
	for(var i = 1; i <= numNode; i++){
		eval('slider_mass_' + i +'.value = mass[' + j + '];');
		eval('slider_stif_' + i +'.value = stif[' + j + '];');
		eval('slider_damp_' + i +'.value = damp[' + j + '];');
		j++;		
	}
}
// 操作パネルにスライダーを配置させるためのテーブルを定義
//テーブル要素作成(idをsetParTableに設定)
var table = document.createElement('table');
var tbody = document.createElement('tbody');
table.id  = 'setParTable';


// ####### 見出し行 #######
var tr 		= document.createElement('tr');
var th_mass 	= document.createElement('th');
th_mass.appendChild(document.createTextNode('質量'));
th_mass.setAttribute("class","a");
th_mass.setAttribute("colspan",numNode);

var th_stif = document.createElement('th');
th_stif.appendChild(document.createTextNode('剛性'));
th_stif.setAttribute("class","a");
th_stif.setAttribute("colspan",numNode);

var th_damp = document.createElement('th');
th_damp.appendChild(document.createTextNode('減衰'));
th_damp.setAttribute("class","a");
th_damp.setAttribute("colspan",numNode);

tr.appendChild(th_mass);
tr.appendChild(th_stif);
tr.appendChild(th_damp);
tbody.appendChild(tr);
// ########################


// #### データ（数値） ####
tr 		= document.createElement('tr');
var icon_mass 	= 0;
var icon_stif 	= 0;
var icon_damp 	= 0;
var count_mass 	= 0;
var count_stif 	= 0;
var count_damp 	= 0;

for (i = 1; i < 3 * numNode + 1; i++) {
	var td_ = document.createElement('td');
  	if(icon_mass == '0'){
		count_mass++;
		eval('td_.appendChild(slider_mass_' + count_mass + ');');
		if(count_mass == numNode){
			icon_mass = 1;
		}
	}
	else if (icon_stif == '0'){
		count_stif++;
		eval('td_.appendChild(slider_stif_' + count_stif + ');');
		if(count_stif == numNode){
			icon_stif = 1;
		}
	}
	else if (icon_damp == '0'){
		count_damp++;
		eval('td_.appendChild(slider_damp_' + count_damp + ');');
		if(count_damp == numNode){
			icon_damp = 1;
		}
	}
	tr.appendChild(td_);
}
tbody.appendChild(tr);
// ########################

// #### データ（スライダー） ####
tr 		= document.createElement('tr');
icon_mass 	= 0;	icon_stif 	= 0;	icon_damp 	= 0;
count_mass 	= 0;	count_stif 	= 0;	count_damp 	= 0;
for (i = 1; i < 3 * numNode + 1; i++) {
	td_ 	= document.createElement('td');
	td_.setAttribute("align","center");
  	if(icon_mass == '0'){
		count_mass++;
		eval("var div_slider_mass_" + count_mass + "= document.createElement('div');");
		eval("div_slider_mass_" + count_mass + ".id = 'div_slider_mass_" + count_mass + "'");
		eval("var div_inner_mass_"  + count_mass + "= document.createElement('div');");
		eval("div_inner_mass_" + count_mass + ".id = 'sec1_o8';");
		eval("var slider_body_mass_" + count_mass + "= document.createElement('input');");
	   	eval("slider_body_mass_" + count_mass + ".type = 'button'")
		eval("slider_body_mass_" + count_mass + ".onmouseover = function(){sliderControl('div_slider_mass_" + count_mass + "','slider_mass_" + count_mass +"',1);}")
		eval("div_slider_mass_" + count_mass + ".setAttribute('class', 'js-slider');");
		eval("div_slider_mass_" + count_mass + ".appendChild(div_inner_mass_" + count_mass +");");
		eval("div_slider_mass_" + count_mass + ".appendChild(slider_body_mass_" + count_mass + ");");		
		eval('td_.appendChild(div_slider_mass_' + count_mass + ');');
		if(count_mass == numNode){
			icon_mass = 1;
		}
	}
	else if (icon_stif == '0'){
		count_stif++;
		eval("var div_slider_stif_" + count_stif + "= document.createElement('div');");
		eval("div_slider_stif_" + count_stif + ".id = 'div_slider_stif_" + count_stif + "'");
		eval("var div_inner_stif_"  + count_stif + "= document.createElement('div');");
		eval("div_inner_stif_" + count_stif + ".id = 'sec1_o8';");
		eval("var slider_body_stif_" + count_stif + "= document.createElement('input');");
	   	eval("slider_body_stif_" + count_stif + ".type = 'button'")
		eval("slider_body_stif_" + count_stif + ".onmouseover = function(){sliderControl('div_slider_stif_" + count_stif + "','slider_stif_" + count_stif +"',2);}")
		eval("div_slider_stif_" + count_stif + ".setAttribute('class', 'js-slider');");
		eval("div_slider_stif_" + count_stif + ".appendChild(div_inner_stif_" + count_stif +");");
		eval("div_slider_stif_" + count_stif + ".appendChild(slider_body_stif_" + count_stif + ");");		
		eval('td_.appendChild(div_slider_stif_' + count_stif + ');');
		if(count_stif == numNode){
			icon_stif = 1;
		}
	}
	else if (icon_damp == '0'){
		count_damp++;
		eval("var div_slider_damp_" + count_damp + "= document.createElement('div');");
		eval("div_slider_damp_" + count_damp + ".id = 'div_slider_damp_" + count_damp + "'");
		eval("var div_inner_damp_"  + count_damp + "= document.createElement('div');");
		eval("div_inner_damp_" + count_damp + ".id = 'sec1_o8';");
		eval("var slider_body_damp_" + count_damp + "= document.createElement('input');");
	   	eval("slider_body_damp_" + count_damp + ".type = 'button'")
		eval("slider_body_damp_" + count_damp + ".onmouseover = function(){sliderControl('div_slider_damp_" + count_damp + "','slider_damp_" + count_damp +"',3);}")
		eval("div_slider_damp_" + count_damp + ".setAttribute('class', 'js-slider');");
		eval("div_slider_damp_" + count_damp + ".appendChild(div_inner_damp_" + count_damp +");");
		eval("div_slider_damp_" + count_damp + ".appendChild(slider_body_damp_" + count_damp + ");");		
		eval('td_.appendChild(div_slider_damp_' + count_damp + ');');
		if(count_damp == numNode){
			icon_damp = 1;
		}
	}
	tr.appendChild(td_);
}
tbody.appendChild(tr);


// #### テーブルをmainDivIDに設置 ####
table.appendChild(tbody);
mainDivID.appendChild(table);


// #### スライダーに設定を反映 ####
sliderAll();

}

</script>
<!-- WebGL -->
<script type="text/javascript" src="js/glMatrix-0.9.5.min.js"></script>
<script type="text/javascript" src="js/webgl-utils.js"></script>

<!-- Shaderのコード-->
<script id="shader-fs" type="x-shader/x-fragment">
    /* floatの精度を指定 */
    precision mediump float;  
    varying vec4 vColor;

    void main(void) {
        gl_FragColor = vColor;
    }
    
</script>

<script id="shader-vs" type="x-shader/x-vertex">
    attribute vec3 aVertexPosition;
    attribute vec3 aVertexNormal;
    attribute vec4 aVertexColor; 

    /* Uniform変数 :shaderの外部からアクセス可能 */
    uniform mat4 uMVMatrix;
    uniform mat4 uPMatrix;
    uniform mat3 uNMatrix;
    uniform float pointSize;

    uniform vec3 uAmbientColor;
    uniform vec3 uLightingDirection;
    uniform vec3 uDirectionalColor;

    varying vec3 vLightWeighting;

    varying vec4 vColor;
    
    void main(void) {
	/* model-view matrix とprojection matrixを掛けたものを最終的な頂点座標として出力 */
        gl_Position 	= uPMatrix * uMVMatrix * vec4(aVertexPosition, 1.0);
        gl_PointSize 	= pointSize;
	vColor 		= aVertexColor;
	
	/* 光源の設定 */
	vec3 transformedNormal = uNMatrix * aVertexNormal;
        float directionalLightWeighting = max(dot(transformedNormal, uLightingDirection), 0.0);
        vLightWeighting = uAmbientColor + uDirectionalColor * directionalLightWeighting;
        
    }
</script>


<script type="text/javascript">
    // マウスによる座標入力
    var grid_x 		= new Array();
    var grid_y 		= new Array();
    // 描画用入力データ
    var view_data 	= new Array();
    // 描画用出力データ
    var d 		= new Array();
    var v 		= new Array();
    var a 		= new Array();
    var t 		= new Array();
    // モデル回転用制御変数
    var mouseDown = false;
    var lastMouseX = null;
    var lastMouseY = null;
    var modelRotationMatrix = mat4.create();
    mat4.identity(modelRotationMatrix);

    function degToRad(degrees) {
        return degrees * Math.PI / 180;
    }

    function handleMouseDown(event) {
        mouseDown = true;
        lastMouseX = event.clientX;
        lastMouseY = event.clientY;
    }

    function handleMouseUp(event) {
        mouseDown = false;
    }

    function handleMouseMove(event) {
        if (!mouseDown) {
            return;
        }
        var newX = event.clientX;
        var newY = event.clientY;

        var deltaX = newX - lastMouseX
        var newRotationMatrix = mat4.create();
        mat4.identity(newRotationMatrix);
        mat4.rotate(newRotationMatrix, degToRad(deltaX / 5), [0, 1, 0]);

        var deltaY = newY - lastMouseY;
        mat4.rotate(newRotationMatrix, degToRad(deltaY / 5), [1, 0, 0]);

        mat4.multiply(newRotationMatrix, modelRotationMatrix, modelRotationMatrix);

        lastMouseX = newX
        lastMouseY = newY;
    }

    // 初期に実行される関数群
    var gl;
    function initGL(canvas) {
        try {
	    gl = canvas.getContext('webgl') || canvas.getContext("experimental-webgl");
	    gl.viewportWidth 	= canvas.width;
            gl.viewportHeight 	= canvas.height;
        } catch (e) {
        }
        if (!gl) {
            alert("Could not initialise WebGL, sorry :-(");
        }
    }

    // フラグメントシェーダ var fragmentShader = getShader(gl, "shader-fs");
    // バーテックスシェーダ var vertexShader = getShader(gl, "shader-vs");
    // シェーダを生成する関数
    function getShader(gl, id) {
        // HTMLからscriptタグへの参照を取得
	var shaderScript = document.getElementById(id);
        if (!shaderScript) {
            return null;
        }

        var str = "";
        var k = shaderScript.firstChild;
        while (k) {
            if (k.nodeType == 3) {
                str += k.textContent;
            }
            k = k.nextSibling;
        }

        var shader;
        if (shaderScript.type == "x-shader/x-fragment") {
            shader = gl.createShader(gl.FRAGMENT_SHADER);
        } else if (shaderScript.type == "x-shader/x-vertex") {
            shader = gl.createShader(gl.VERTEX_SHADER);
        } else {
            return null;
        }

	// 生成されたシェーダにソースを割り当てる
        gl.shaderSource(shader, str);
	// シェーダをコンパイルする
        gl.compileShader(shader);

        if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
            alert(gl.getShaderInfoLog(shader));
            return null;
        }

        return shader;
    }


    var shaderProgram;

    function initShaders() {
        var fragmentShader = getShader(gl, "shader-fs");
        var vertexShader = getShader(gl, "shader-vs");

        shaderProgram = gl.createProgram();
        gl.attachShader(shaderProgram, vertexShader);
        gl.attachShader(shaderProgram, fragmentShader);
        gl.linkProgram(shaderProgram);

        if (!gl.getProgramParameter(shaderProgram, gl.LINK_STATUS)) {
            alert("Could not initialise shaders");
        }

        gl.useProgram(shaderProgram);

        shaderProgram.vertexPositionAttribute = gl.getAttribLocation(shaderProgram, "aVertexPosition");
        gl.enableVertexAttribArray(shaderProgram.vertexPositionAttribute);
	
	shaderProgram.vertexColorAttribute = gl.getAttribLocation(shaderProgram, "aVertexColor");
        gl.enableVertexAttribArray(shaderProgram.vertexColorAttribute);
	
        shaderProgram.pMatrixUniform = gl.getUniformLocation(shaderProgram, "uPMatrix");
        shaderProgram.mvMatrixUniform = gl.getUniformLocation(shaderProgram, "uMVMatrix");
	shaderProgram.nMatrixUniform = gl.getUniformLocation(shaderProgram, "uNMatrix");	// 光源用：各頂点の法線ベクトル
        shaderProgram.useLightingUniform = gl.getUniformLocation(shaderProgram, "uUseLighting");
        shaderProgram.ambientColorUniform = gl.getUniformLocation(shaderProgram, "uAmbientColor");
        shaderProgram.lightingDirectionUniform = gl.getUniformLocation(shaderProgram, "uLightingDirection");
        shaderProgram.directionalColorUniform = gl.getUniformLocation(shaderProgram, "uDirectionalColor");
    
    }


    var mvMatrix = mat4.create();
    var mvMatrixStack = [];
    var pMatrix = mat4.create();

    function mvPushMatrix() {
        var copy = mat4.create();
        mat4.set(mvMatrix, copy);
        mvMatrixStack.push(copy);
    }
    function mvPopMatrix() {
        if (mvMatrixStack.length == 0) {
            throw "Invalid popMatrix!";
        }
        mvMatrix = mvMatrixStack.pop();
    }

    // initShader関数で取得したprojection matrixとmodel-view matrixを表すuniform変数への参照を利用してWebGLにJavaScript形式のmatrixを渡します。
    function setMatrixUniforms() {
        gl.uniformMatrix4fv(shaderProgram.pMatrixUniform, false, pMatrix);
        gl.uniformMatrix4fv(shaderProgram.mvMatrixUniform, false, mvMatrix);
	
	// 光源の扱い
	// 参考：法線は頂点と同じmodel-view matrixを使って同じ方法で変換することはできない。
	// >> 法線が回転だけでなく移動もするため
	// 対処方法１：vertex shaderで3要素の頂点座標を4x4のmodel-view matrixで乗算を行うために頂点に値１の要素を最後に追加することで2つの間の互換性を持たせる。
	//             この１は単なる詰め物なだけでなく、回転だけでなく移動や他の変形を乗算に適用させるようにするためです。
	// 	       そして最後に追加する要素を１でなく0とすることで、乗算が移動を無視するようになります。
	// 問題：しかし不運なことにこの方法ではmodel-view matrixにスケーリング（拡大、縮小）や剪断が含まれているときにはうまく行きません。
	// 対処方法２：法線に正しい方向を示させるためには、model-view matrixの逆行列を転置したものを使う事です。

	var normalMatrix = mat3.create();
        mat4.toInverseMat3(mvMatrix, normalMatrix);
        mat3.transpose(normalMatrix);
        gl.uniformMatrix3fv(shaderProgram.nMatrixUniform, false, normalMatrix);
    }


    // bufferを保存するためのグローバル変数を定義する。
    var triangleVertexPositionBuffer;
    var waveVertexPositionBuffer;    
    var triangleVertexColorBuffer;
    var waveVertexColorBuffer;

    var BuildModelColorBuffer;
    var cubeVertexPositionBuffer;
    var cubeVertexNormalBuffer;
    var cubeVertexColorBuffer;
    var cubeVertexIndexBuffer;

    // マーカーのサイズ
    var pointSize = Number(5);

    function initBuffers() {
        triangleVertexPositionBuffer = gl.createBuffer();
        // WebGLに以降のbufferに対する操作は全てこの引数として指定したbufferに対して行うように伝える。
	// この操作時に対象のbufferを指定するのではなく、あらかじめ"current array buffer"を指定→操作の実行が必須。
	
	gl.bindBuffer(gl.ARRAY_BUFFER, triangleVertexPositionBuffer);
 	
	// 変数vertex:図形の3D空間での座標
	var grid = new Array();
	// X軸
	grid.push(-30,0,0,30,0,0);
	// Y軸
	grid.push(0,-10,0,0,10,0);
	// X軸目盛
	for(var i=0;i<121;i++){
	grid.push(-30+0.5*i,-0.2,0,-30+0.5*i,0.2,0);
	}
	var vertices = grid;
	
	// JavaScriptの配列をもとにFloat32Array objectを作ってWebGLに"Current Buffer"にこの値を設定する
        gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(vertices), gl.STATIC_DRAW);
        triangleVertexPositionBuffer.itemSize = 3;
        triangleVertexPositionBuffer.numItems = 240;

	triangleVertexColorBuffer = gl.createBuffer();
	gl.bindBuffer(gl.ARRAY_BUFFER, triangleVertexColorBuffer);
	var colors = new Array();
	for(i = 0; i<240;i++){
	colors.push(1.0,1.0,1.0,1.0);
	}
	gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(colors),gl.STATIC_DRAW);
	triangleVertexColorBuffer.itemSize = 4;
	triangleVertexColorBuffer.numItems = 240;

	
	// ***********************************************
	// 色情報 : 波形
	waveVertexColorBuffer = gl.createBuffer();
	gl.bindBuffer(gl.ARRAY_BUFFER, waveVertexColorBuffer);
	var colors = new Array();
	for(i = 0; i<601;i++){
	colors.push(5.0-1/600*i,1/600*i,0.0,5.0);
	}
	gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(colors),gl.STATIC_DRAW);
	waveVertexColorBuffer.itemSize = 4;
	waveVertexColorBuffer.numItems = 600;
	
	// 色情報 : 建物モデル
	BuildModelColorBuffer = gl.createBuffer();
	gl.bindBuffer(gl.ARRAY_BUFFER, BuildModelColorBuffer);
	var Buildcolors = new Array();
	for (i = 0; i < 4; i++) {
            Buildcolors = Buildcolors.concat([5.0, 5.0, 5.0, 5.0]);
        }
	gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(Buildcolors),gl.STATIC_DRAW);
	BuildModelColorBuffer.itemSize = 4;
	BuildModelColorBuffer.numItems = 4;
	
	// 色情報：キューブ
	cubeVertexColorBuffer = gl.createBuffer();
        gl.bindBuffer(gl.ARRAY_BUFFER, cubeVertexColorBuffer);
        colors = [
            [5.0, 0.0, 0.0, 5.0], // Front face
            [5.0, 5.0, 0.0, 5.0], // Back face
            [0.0, 5.0, 0.0, 5.0], // Top face
            [5.0, 0.5, 0.5, 5.0], // Bottom face
            [5.0, 0.0, 5.0, 5.0], // Right face
            [0.0, 0.0, 5.0, 5.0]  // Left face
        ];
        var unpackedColors = [];
        for (var i in colors) {
            var color = colors[i];
            for (var j=0; j < 4; j++) {
                unpackedColors = unpackedColors.concat(color);
            }
        }
        gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(unpackedColors), gl.STATIC_DRAW);
        cubeVertexColorBuffer.itemSize = 4;
        cubeVertexColorBuffer.numItems = 24;

	// キューブ頂点インデックス
	cubeVertexIndexBuffer = gl.createBuffer();
        gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, cubeVertexIndexBuffer);
        var cubeVertexIndices = [
            0, 1, 2,      0, 2, 3,    // Front face
            4, 5, 6,      4, 6, 7,    // Back face
            8, 9, 10,     8, 10, 11,  // Top face
            12, 13, 14,   12, 14, 15, // Bottom face
            16, 17, 18,   16, 18, 19, // Right face
            20, 21, 22,   20, 22, 23  // Left face
        ];
        gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, new Uint16Array(cubeVertexIndices), gl.STATIC_DRAW);
        cubeVertexIndexBuffer.itemSize = 1;
        cubeVertexIndexBuffer.numItems = 36;

	// キューブ法線ベクトル
	cubeVertexNormalBuffer = gl.createBuffer();
        gl.bindBuffer(gl.ARRAY_BUFFER, cubeVertexNormalBuffer);
        var vertexNormals = [
            // Front face
             0.0,  0.0,  1.0,
             0.0,  0.0,  1.0,
             0.0,  0.0,  1.0,
             0.0,  0.0,  1.0,

            // Back face
             0.0,  0.0, -1.0,
             0.0,  0.0, -1.0,
             0.0,  0.0, -1.0,
             0.0,  0.0, -1.0,

            // Top face
             0.0,  1.0,  0.0,
             0.0,  1.0,  0.0,
             0.0,  1.0,  0.0,
             0.0,  1.0,  0.0,

            // Bottom face
             0.0, -1.0,  0.0,
             0.0, -1.0,  0.0,
             0.0, -1.0,  0.0,
             0.0, -1.0,  0.0,

            // Right face
             1.0,  0.0,  0.0,
             1.0,  0.0,  0.0,
             1.0,  0.0,  0.0,
             1.0,  0.0,  0.0,

            // Left face
            -1.0,  0.0,  0.0,
            -1.0,  0.0,  0.0,
            -1.0,  0.0,  0.0,
            -1.0,  0.0,  0.0
        ];
        gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(vertexNormals), gl.STATIC_DRAW);
        cubeVertexNormalBuffer.itemSize = 3;
        cubeVertexNormalBuffer.numItems = 24;

    }

    var rdata = new Array();
    // 描画を行うための関数
    function drawScene() {
	// viewport関数: WebGLにcanvasの大きさを伝える
        gl.viewport(0, 0, gl.viewportWidth, gl.viewportHeight);
	
	// 描画の準備としてcanvasを消去
        gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);

	// ここでシーンをどのように見せたいかの設定とともにperspectiveを設定します。
	// ここでの設定：シーンの（垂直）視野角として45度、canvasの幅と高さの比、視点にこれより近づいたら表示しない距離として0.1、これ以上離れたら表示しないという距離として100
	mat4.perspective(45, gl.viewportWidth / gl.viewportHeight, 0.1, 100.0, pMatrix);
	mat4.identity(mvMatrix);
	
	// 座標位置の移動（カメラのアングル？）
        mat4.translate(mvMatrix, [0.0, 0.0, -15.0]);

	// ########################################
	mvPushMatrix();

        gl.bindBuffer(gl.ARRAY_BUFFER, triangleVertexPositionBuffer);
        gl.vertexAttribPointer(shaderProgram.vertexPositionAttribute, triangleVertexPositionBuffer.itemSize, gl.FLOAT, false, 0, 0);

	gl.bindBuffer(gl.ARRAY_BUFFER,triangleVertexColorBuffer);
	gl.vertexAttribPointer(shaderProgram.vertexColorAttribute,triangleVertexColorBuffer.itemSize,gl.FLOAT, false, 0,0);
	
	// これはWebGLにcurrentのmodel-view matrix(それとprojection matrixもだけど、それはまた後で)を利用するように伝えます。
	// model-view matrixをグラフィックカードに送る
        setMatrixUniforms();
	
	// uniformLocationを配列に取得
	var uniLocation = new Array();
	uniLocation[0]  = gl.getUniformLocation(shaderProgram, 'uMVMatrix');
	uniLocation[1]  = gl.getUniformLocation(shaderProgram, 'pointSize');
	
	// ここまでの処理が終わると、WebGLは頂点として扱われるべき座標の配列とmatrixを持っています。
	// ここでの処理イメージ ⇒ 先ほど渡した頂点配列で三角形を描画しなさい。頂点は配列の０番の要素からnumItems番目の要素まで使いなさい
	// 第１引数をプリミティブタイプという。
	// プリミティブタイプの種類: POINTS	 ⇒1つの頂点を１つの点として描画
	// プリミティブタイプの種類: LINES	 ⇒頂点を順に結んでいくが，直線は連続しない
	// プリミティブタイプの種類: LINE_STRIP  ⇒頂点を順に結んでいき，直線が連続する
	// プリミティブタイプの種類: LINE_LOOP   ⇒頂点を順に結んでいき，開始と終端の頂点も結ばれる。

	gl.uniform1f(uniLocation[1], pointSize);

        //gl.drawArrays(gl.POINTS, 0, triangleVertexPositionBuffer.numItems);
        gl.drawArrays(gl.LINES, 0, triangleVertexPositionBuffer.numItems);
        mvPopMatrix();

	// *****************************************************
	// 波形を描画
	// 時刻歴波形データ
	
	mvPushMatrix();
	// 【入力】波形データの頂点座標を更新
　　    var num_input_data 	= view_data.length;
        var input_data     	= new Float32Array(num_input_data);
	var j_input        	= num_input_data - 1;
	// 描画用データview_dataを頂点マトリクス生成用データr_dataに格納
	for(var i = 0; i < 600; i++){
		if(view_data[j_input]){
			input_data[i] = parseFloat((view_data[j_input]-250)/100);
		}
		j_input    	= j_input - 1;
        }
	
	// 【出力】波形データの頂点座標を更新
　　    var num_output_data 	= d.length;
        var output_data    	= new Float32Array(num_output_data);
        var output_t    	= new Float32Array(num_output_data);
	var j_output       	= num_output_data - 1;
	// 描画用データview_dataを頂点マトリクス生成用データr_dataに格納
	for(i = 0; i < 600; i++){
		if(d[j_output]){
			output_data[i] = parseFloat((d[j_output])*2);
			if(i == 0){
				output_t[i]    = 0;
			}
			else{
				output_t[i]    = output_t[i-1] + parseFloat(t[j_output]);
			}
		}
		j_output 	= j_output - 1;
        }
	if(output_t[0]){
	alert(output_t[0]);
	alert(output_t[1]);
	alert(output_t[2]);
	}
	// ラジオボタンによる波形描画の切り替え
	var IO_conf = document.getElementsByName("IO");
	for(i = 0; i < IO_conf.length; i++){
	    	if (IO_conf[i].checked) {
			if(IO_conf[i].value == '0'){
				var r_data = input_data;
				var icon_wave    = 1;
				var icon_view_IO = 0;
			}
			else if(IO_conf[i].value == '1'){
				var wave_conf = document.getElementsByName("ViewWave");
				if(wave_conf[0].checked){
					var icon_wave = 1;
				}
				else{
					var icon_view = 0;
				}
				var r_data = output_data;
				var icon_view_IO = 1;
			}
		}
	}
	waveVertexPositionBuffer = gl.createBuffer();
        gl.bindBuffer(gl.ARRAY_BUFFER, waveVertexPositionBuffer);
	if(icon_wave == '1'){
	r_wave_vertices = new Array();
	for(i=0;i<601;i++){
		if(output_data[i]){
			r_wave_vertices.push(15-30/1000*output_t[i],2*r_data[i],0);	
		}
		else{
			r_wave_vertices.push(15-30/1000*output_t[i],0.0,0);
		}
	}
	gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(r_wave_vertices),gl.DYNAMIC_DRAW);
	waveVertexPositionBuffer.itemSize = 3;
	waveVertexPositionBuffer.numItems = 600;
	    
	gl.bindBuffer(gl.ARRAY_BUFFER, waveVertexPositionBuffer);
        gl.vertexAttribPointer(shaderProgram.vertexPositionAttribute, waveVertexPositionBuffer.itemSize, gl.FLOAT, false, 0, 0);
	gl.bindBuffer(gl.ARRAY_BUFFER, waveVertexColorBuffer);
        gl.vertexAttribPointer(shaderProgram.vertexColorAttribute, waveVertexColorBuffer.itemSize, gl.FLOAT, false, 0, 0);
	
	//gl.drawArrays(gl.POINTS, 0, waveVertexPositionBuffer.numItems);
        gl.drawArrays(gl.LINE_STRIP, 0, waveVertexPositionBuffer.numItems);
        mvPopMatrix();
	}
	if(icon_view_IO == 1){
		mvPushMatrix();
		cubeVertexPositionBuffer = gl.createBuffer();
	        gl.bindBuffer(gl.ARRAY_BUFFER, cubeVertexPositionBuffer);
	        vertices = [
	            // Front face
	            -3.0,  -3.0, 3.0 ,
	             3.0,  -3.0, 3.0 ,
	             3.0 + parseFloat(r_data[5])*5,  3.0, 3.0 ,
	            -3.0 + parseFloat(r_data[5])*5,  3.0, 3.0 ,

	            // Back face
	            -3.0, -3.0, -3.0,
	            -3.0 + parseFloat(r_data[5])*5,  3.0, -3.0,
	             3.0 + parseFloat(r_data[5])*5,  3.0, -3.0,
	             3.0, -3.0, -3.0,

	            // Top face
	            -3.0 + parseFloat(r_data[5])*5,  3.0, -3.0,
	            -3.0 + parseFloat(r_data[5])*5,  3.0,  3.0,
	             3.0 + parseFloat(r_data[5])*5,  3.0,  3.0,
	             3.0 + parseFloat(r_data[5])*5,  3.0, -3.0,

	            // Bottom face
	            -3.0, -3.0, -3.0,
	             3.0, -3.0, -3.0,
	             3.0, -3.0,  3.0,
	            -3.0, -3.0,  3.0,

	            // Right face
	             3.0, -3.0, -3.0,
	             3.0 + parseFloat(r_data[5])*5,  3.0, -3.0,
	             3.0 + parseFloat(r_data[5])*5,  3.0,  3.0,
	             3.0, -3.0,  3.0,

	            // Left face
	            -3.0, -3.0, -3.0,
	            -3.0, -3.0,  3.0,
	            -3.0 + parseFloat(r_data[5])*5,  3.0,  3.0,
	            -3.0 + parseFloat(r_data[5])*5,  3.0, -3.0
	        ];
		//squareVertexPositionBuffer = gl.createBuffer();
	        //gl.bindBuffer(gl.ARRAY_BUFFER, squareVertexPositionBuffer);
	        //vertices = [
	        //     5.0 + parseFloat(r_data[5])*5,  5.0,  0.0,
	        //    -5.0 + parseFloat(r_data[5])*5,  5.0,  0.0,
	        //     5.0, -5.0,  0.0,
	        //    -5.0, -5.0,  0.0
	        //];
	        gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(vertices), gl.STATIC_DRAW);
		cubeVertexPositionBuffer.itemSize = 3;
		cubeVertexPositionBuffer.numItems = 24;
		setMatrixUniforms();
		mat4.multiply(mvMatrix, modelRotationMatrix);
		mat4.rotate(mvMatrix, 0.5, [0, 1, 0]);
		// 建物モデルの描画
		// 色情報の更新
		//  
		gl.bindBuffer(gl.ARRAY_BUFFER, cubeVertexPositionBuffer);
	        gl.vertexAttribPointer(shaderProgram.vertexPositionAttribute, cubeVertexPositionBuffer.itemSize, gl.FLOAT, false, 0, 0);
	
	        gl.bindBuffer(gl.ARRAY_BUFFER, cubeVertexNormalBuffer);
	        gl.vertexAttribPointer(shaderProgram.vertexNormalAttribute, cubeVertexNormalBuffer.itemSize, gl.FLOAT, false, 0, 0);
		gl.uniform3f(shaderProgram.ambientColorUniform,parseFloat(0.1),parseFloat(0.1),parseFloat(0.1));
		var lightingDirection = [-1,-1,0.5];
           	var adjustedLD = vec3.create();
	        vec3.normalize(lightingDirection, adjustedLD);
	        vec3.scale(adjustedLD, -1);
	        gl.uniform3fv(shaderProgram.lightingDirectionUniform, adjustedLD);
		gl.uniform3f(shaderProgram.directionalColorUniform,parseFloat(0.8),parseFloat(0.8),parseFloat(0.8));                
		
	        gl.bindBuffer(gl.ARRAY_BUFFER, cubeVertexColorBuffer);
	        gl.vertexAttribPointer(shaderProgram.vertexColorAttribute, cubeVertexColorBuffer.itemSize, gl.FLOAT, false, 0, 0);

	        gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, cubeVertexIndexBuffer);
	        setMatrixUniforms();
	        gl.drawElements(gl.TRIANGLES, cubeVertexIndexBuffer.numItems, gl.UNSIGNED_SHORT, 0);
		mvPopMatrix();
	}
	// *****************************************************

    }
    

    // 波形アニメーションの為の制御変数
    var lastTime_wave   = 0;
    var dt  		= parseFloat(0.02);
    var curTime 	= 0;
    function animate_count(){
	var timeNow = new Date().getTime();
        var elapsed = timeNow - lastTime_wave;
	
	// elapsed:時間刻み→描画用データを一定の時間刻みで取得する
	// grid_xは座標データ	
	if(elapsed > 20){
		view_data.push(grid_x[grid_x.length-1]);
		if(d[d.length-1]){
			dt 	= parseFloat(elapsed)/1000;
			curTime = parseFloat(dt)/0.02;
			var d_  = parseFloat(d[d.length-1]);
			var v_  = parseFloat(v[v.length-1]);
			var a_  = parseFloat(a[a.length-1]);
		}else{
			var d_  = 0;
			var v_  = 0;
			var a_  = 0;
		}		
		var l_  = parseFloat((grid_x[grid_x.length-1]-250)/500);
		//if(grid_x[grid_x.length-3]){
		//	var l_ = diff_disp2acc((grid_x[grid_x.length-3]-250)/2000,(grid_x[grid_x.length-2]-250)/2000,(grid_x[grid_x.length-1]-250)/2000);
		//}
		//else{
		//	var l_  = 0;
		//}
		timeHistoryAnalysis(d_,v_,a_,l_);
		d.push(disp);
		v.push(vel);
		a.push(acc);
		t.push(curTime);
		lastTime_wave = timeNow;
	}
    }

    function tick() {
	if(tick.animate){
	        requestAnimFrame(tick);
		drawScene();
	        animate_count();	// 波形アニメーションの制御パラメタ
	}
    }
    // ■sample3.htmlから追加(ここまで)■

    
    // ※webGLを開始する関数（描画開始からまずはじめに実行される関数）
    function webGLStart() {	    
    	    var count = 0;
	    var canvas = document.getElementById("lesson03-canvas"); 	// 3Dの描画先となるcanvas element
	    initGL(canvas);
	    initShaders();
	    initBuffers();						// Bufferの初期化
	    
	    gl.clearColor(0.0, 0.0, 0.0, 1.0);
	    gl.enable(gl.DEPTH_TEST);
	    canvas.onmousedown 	 = handleMouseDown;
            canvas.onmouseup 	 = handleMouseUp;
            canvas.onmousemove 	 = handleMouseMove;

	    tick.animate = true;
	    tick();
    }

    // 描画の停止ボタン
    function webGLStop(){
    	tick.animate = false;
    }


function getMousePosition_interval(){
     grid_x.push(event.x + document.body.scrollLeft);
     if(grid_x.length > 800){
		grid_x = grid_x.splice(150);
		d      = d.splice(150);
		v      = v.splice(150);
		a      = a.splice(150);
		t      = t.splice(150);
     }
}

var icon  = 0;
var timer;
var m;
var c;
var k;
var err_m = 0;
var err_k = 0;
var err_c = 0;

function setMCK(){
	if(numNode == '1'){
		m 	= parseFloat(document.getElementById('slider_mass_1').value);
		k 	= parseFloat(document.getElementById('slider_stif_1').value);
		c 	= parseFloat(document.getElementById('slider_damp_1').value);
	}
	else if(numNode == '2'){
	alert('開発中です');
	}
	if(m){
	}else{
		if(err_m == 0){
			alert('質量が未入力です');
			err_m = 1;
		}
	}
	if(c){
	}else{
		if(err_c == 0){
			err_c = 1;
		}
	}
	if(k){
	}else{
		if(err_k == 0){
			err_k = 1;
		}
	}
}
function setPosition(){
	window.document.onmousedown = function(e){
		icon = 1;
		window.document.onmousemove = function(e){
		    	getMousePosition_interval();
     		}
	}
}


function offPosition(){
	window.document.onmouseout = function(e){
		if(icon == 1){
			icon = 0;
		}
		window.document.onmousedown = function(e){
		}
		window.document.onmousemove = function(e){
		// mousemoveに対して何も処理を行わない
		}
	}
}

// ■■■　平均加速度法による1質点系時刻歴応答解析 ■■■
var disp 	= parseFloat(0);
var vel 	= parseFloat(0);
var acc 	= parseFloat(0);
function timeHistoryAnalysis(disp_,vel_,acc_,loading){
	var timeStart = new Date().getTime();
        acc 	= (loading - c/m*(vel_ + acc_*dt/2) - k/m*(disp_+vel_*dt + 0.25*acc_*Math.pow(dt,2)))/(1 + c/m*dt/2 + k/m*Math.pow(dt,2)/4);
	vel 	= vel_ + (acc + acc_)/2*dt;
	disp 	= disp_ + vel_*dt + (acc + acc_)/4*Math.pow(dt,2);
	var timeEnd   = new Date().getTime() - timeStart;
	return disp,vel,acc;
}

// ■■■ 変位データ→加速度データ ■■■
function diff_disp2acc(disp1,disp2,disp3){
    var acc_ = ((disp3-disp2)-(disp2-disp1))/Math.pow(dt,2);
    //alert(acc_);
    return acc_; 
}

function ToggleOff(){
	document.mainForm.ViewWave.checked = false;
}
</script>


</head>


<!-- ##### ページ本体(HTML)はここから ##### -->
<body onLoad="webGLStart();
	      set_MinMax();
	      setTable();
">

<div style="background-color:RGB(240,240,240);width:540px;">
<p style="padding:5px 5px;"><h3 style="margin-left:20px;">1質点系時刻歴解析シミュレーションのサンプル</h3></p>

<hr width=500px align=left style="margin-left:20px;">
    <canvas id="lesson03-canvas" style="border: none;margin-left:20px;" width="500" height="200"></canvas>
    <!-- CanvasはHTML 5.0のための新しいタグ　ここでは<canvas>タグではレイアウトを調整する簡単な属性以外は指定されていない。
	 WebGLのJavaScriptのセットアップはページが読み込まれたときに一度だけ呼ばれるwebGLStart関数から呼び出されている。 
    -->
    <br/>

<hr width=500px align=left style="margin-left:20px;">
<p style="margin-left:20px;">
画像をクリックして，マウスを動かしてください。<br>
画像からマウスが離れると，波形データの入力が終了します。<br>
</p>
<img src="images/fig_sample5.png" style="width:500px;background-color:RGB(255,255,255);margin-left:20px;" onmouseover="setPosition();" onclick="this.src='images/fig_sample5_2.png';webGLStart();setMCK();" onmouseout ="offPosition();this.src='images/fig_sample5.png';">
<br>
<form NAME="mainForm">
<p style="margin-left:20px;">入力波形を表示<input type="radio" name="IO" value=0 onclick="ToggleOff();">&nbsp;&nbsp;／&nbsp;&nbsp;モデルの応答を表示<input type="radio" name="IO" value=1 checked>&nbsp;※波形も同時に表示<input type="checkbox" name="ViewWave"></p>
</form>

<hr width=500px align=left style="margin-left:20px;">

<div style="background-color:RGB(100,100,100);margin:10px 10px;height:150px;">
	<form class="js-slider-form" onsubmit="return false;">
	<div id="panel" style="background-color:RGB(100,100,100);width:400px;height:150px;float:left;overflow:auto;">
	<!-- 参照：http://gihyo.jp/dev/serial/01/crossbrowser-javascript/0023 -->
	</div>

	<div id="panel_right" style="background-color:RGB(100,100,100);margin:10px 10px;width:100px;float:right;">
	<table>
	    <tr><!--設定できる諸元範囲を指定する-->
		<td style="width:380px;"rowspan="1" align="right"><button style="width:80px;" id="button_1" onclick="changeValue('menu_1','戻る','建物選択');setModel('0');"><div id="menu_1">建物選択</div></button></td>
	    </tr>
	    <tr>
		<td style="width:380px;"rowspan="1" align="right"><button style="width:80px;" id="button_2" onmousedown="changeValue('menu_2','戻る','諸元設定');setPar();"><div id="menu_2">諸元設定</div></button></td>
	    </tr>
	    <tr>
	    <!--入力波形(地震波を指定するなど)の設定-->
	    <td style="width:380px;"rowspan="2" align="right"><button style="width:80px;" id="button_3" onmousedown="changeValue('menu_3','戻る','入力設定');setInput();"><div id="menu_3">入力設定</div></button></td>
	    </tr>
   	</table>
 
	   <div class="optionmenu" id="parModel">
	   建物をリストから選択してください。<br>
	   指定した建物モデルの諸元が設定されます。<br>
	   <select id="ModelList">
	   <option value="0">---選択してください---</option>
	   <option value="1">建物モデル１</option>
	   <option value="2">建物モデル２</option>
	   <option value="3">建物モデル３</option>
	   <option value="4">建物モデル４(2自由度系)</option>
	   <option value="51">建物モデル５(5自由度系)</option>
	   </select>
	   <button onclick="changeValue('menu_1','戻る','建物選択');setModel(1);setTable();">選択</button>
	   </div>
	   <div class="optionmenu" id="par">
	   質量最小値：<input type="text" value="" id="mass_min" style="width:100px;">／質量最小値：<input type="text" value="" id="mass_max" style="width:100px;"><br>
	   剛性最小値：<input type="text" value="" id="stif_min" style="width:100px;">／剛性最小値：<input type="text" value="" id="stif_max" style="width:100px;"><br>
	   減衰最小値：<input type="text" value="" id="damp_min" style="width:100px;">／減衰最小値：<input type="text" value="" id="damp_max" style="width:100px;">
	   </div>
	   <div class="optionmenu" id="par_input" style="display:none;">
	   地震波をリストから選択してください。<br>
	   開始ボタンを押すと現在の建物モデルに地震波が入力されます。<br>
	   <select id="EarthQuakeList">
	   <option>---選択してください---</option>
	   <option value="1">El&nbsp;Centro&nbsp;NS&nbsp;(1940)</option>
	   <option value="2">Taft&nbsp;(1952)</option>
	   <option value="2">Hachinohe&nbsp;(1968)</option>
	   </select>
	   <button disabled>開始</button>※まだ使用できません
	   </div>
	</form>
	</div>
	</div>
</body>

</html>
